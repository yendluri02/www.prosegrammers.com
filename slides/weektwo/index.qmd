---
title: "Exploring the Python Programming Language"
description: "What are some of the key features of Python?"
date: "2025-09-01"
date-format: long
author: Gregory M. Kapfhammer
execute:
  echo: true
format:
  live-revealjs:
    completion: true
    theme: default
    css: ../css/styles.css
    history: false
    scrollable: true
    transition: slide
    highlight-style: github
    footer: "Prosegrammers"
---

# What are some key features of the Python programming language?

::: incremental

- Simple and readable syntax
- Defining and evaluating expressions
- Declaring and using variables with types
- Creating and using collections

:::

## Python for document engineering

::: {.incremental .fade-right style="margin-top: -0.2em; font-size: 0.775em;"}

- {{< iconify fa6-solid gear >}} **Simple and readable syntax**
  - Easy to learn and understand
  - Code looks similar to written English
  - Focus on solving problems, not complex syntax

- {{< iconify fa6-solid code >}} **Excellent text processing capabilities**
  - Built-in string operations and methods
  - Rich collection types for organizing data
  - Powerful libraries for document manipulation

- {{< iconify fa6-solid book-open >}} **Perfect suite of tools for prosegrammers**
  - Combines programming power with clear, readable code
  - Ideal for creating tools that work with documents

:::

# Thinking and writing about Python programs

::: incremental

- **Sequence**: Run operations one after another in an order
- **Selection**: Decide which operations will execute
- **Iteration**: Repeat an operation a specific number of times

:::

::: {.fragment .fade .boxed-content style="font-size: 1.0em;"}

{{< iconify fa6-solid microscope >}} These three concepts form the foundation of
all programming logic! **Let's explore these in greater detail!**

:::

## Sequence: Run operations one-by-one

```{python}
def create_greeting(name: str) -> str:
    """Create a personalized greeting message for documents."""
    greeting = "Hello, " + name + "!"
    message = greeting + " Welcome to Document Engineering."
    return message

# call the function with different names
result = create_greeting("Alice")
print(result)
```

::: {.incremental .fade style="margin-top: -0.25em; font-size: 0.8em;"}

- Calling the `create_greeting` function causes each line to run sequentially
- **First**: concatenate name with `"Hello, "` and `"!"`
- **Second**: add the welcome message to create full greeting
- **Third**: return the complete message to caller
- **Document connection**: generating personalized content for reports!

:::

## Selection: Use conditional logic

```{python}
def format_document_title(title: str, capitalized: bool) -> str:
    """Format a document title based on style preference."""
    if capitalized:
        formatted_title = title.upper()
        result = "DOCUMENT: " + formatted_title
    else:
        formatted_title = title.title()
        result = "Document: " + formatted_title
    return result

# test both formatting styles
print(format_document_title("user guide", True) + " / "
      + format_document_title("user guide", False))
```

::: {.incremental .fade style="margin-top: -0.25em; font-size: 0.8em;"}

- The `if` statement checks the value of the `formal` parameter
- Different code executes based on whether `formal` is `True` or `False`
- **Document connection**: adapting content style for different audiences!

:::

## Iteration: Repeat an operation

```{python}
def count_words_in_documents(documents: list) -> dict:
    """Count total words across multiple documents."""
    word_counts = {}
    for doc_name in documents:
        word_count = len(doc_name.split())  # simple word count
        word_counts[doc_name] = word_count
    return word_counts

# test with sample document names
docs = ["Manual", "Installation Guide", "API Reference Document"]
counts = count_words_in_documents(docs)
print(counts)
```

::: {.incremental .fade style="margin-top: -0.25em; font-size: 0.8em;"}

- `word_counts` is a dictionary that starts out empty
- The `for` loop iterates through each document name in the list
- **Document connection**: analyzing multiple documents in a collection!

:::

# Collections contain multiple values

::: {.fragment .fade-right}
- {{< iconify fa6-solid font >}} **Strings**: `str` in Python
- {{< iconify fa6-solid bars >}} **Lists**: `list` in Python
- {{< iconify fa6-solid link >}} **Tuples**: `tuple` in Python
- {{< iconify fa6-solid table >}} **Dictionaries**: `dict` in Python
- {{< iconify fa6-solid tags >}} **Sets**: `set` in Python
:::

::: {.fragment .fade-up style="margin-top: -0.5em;"}
**Let's explore how these work and what are their differences!**
:::

## Creating and using a string

```{pyodide}
#| autorun: true
#| max-lines: 5
title = "Document Engineering: "
subtitle = "A Beginner's Guide"
full_title = title + subtitle
page_number = str(42)
print("Title type:", type(full_title))
print("Full title:", full_title)
print("Character at position 9:", full_title[9])
print("Page as string:", page_number[0])
```

::: {.incremental style="margin-top: -0.25em; font-size: 0.85em;"}

- What is the purpose of the `type` function?
- What is the purpose of the `full_title[9]` notation?
- What is the purpose of the `str` function?
- What is the purpose of the `+` operator?

:::

## Creating and using a list

```{pyodide}
#| autorun: true
#| max-lines: 8
# lists store multiple items - great for document sections!
chapters = ["Introduction", "Basics", "Advanced", "Conclusion"]
print("List type:", type(chapters))
chapters.append("Appendix")
print("First chapter:", chapters[0])
print("Second chapter:", chapters[1])
print("Last chapter:", chapters[-1])
print("Second to last:", chapters[-2])
chapters[2] = "Intermediate"
chapters[3] = "Expert Topics"
print("Updated chapters:", chapters)
```

::: {.fragment .fade-up style="margin-top: -0.05em; font-size: 0.9em;"}

What does this illustrate about the `list` type in Python?

:::

## Creating and using a tuple

```{pyodide}
#| autorun: true
#| max-lines: 4
# tuples store immutable data - perfect for document metadata!
doc_info = ("User Manual", "v2.1", "2025-09-01", "PDF", "42 pages")
print("Tuple type:", type(doc_info))
print("Document info:", doc_info)
print("Document format:", doc_info[3])
print("Page count:", doc_info[4])
```

::: {.fragment .fade-up style="margin-top: -0.1em; font-size: 0.8em;"}

- A `tuple` is an immutable collection of ordered values
- What are some invalid operations on a `tuple`?
  - `doc_info[3] = "DOCX"`
  - `doc_info.append("English")`
  - `doc_info.remove("PDF")`
- **Document connection**: storing fixed document properties!

:::

## Creating and using a dictionary

```{pyodide}
#| autorun: true
#| max-lines: 10
# dictionaries store key-value pairs - ideal for document properties!
document = dict()
document["title"] = "Python Programming Guide"
document["author"] = "Jane Smith"
document["pages"] = 156
document["language"] = "English"
print("Dictionary type:", type(document))
print("Document details:", document)
print("Document title:", document["title"])
print("Page count:", document["pages"])
```

::: {.fragment .fade-up style="margin-top: -0.1em; font-size: 0.8em;"}

- A dictionary stores **key-value pairs** in an **associative mapping**

:::

## Details about dictionary use in Python

::: {.incremental .fade-up style="margin-top: -0.1em; font-size: 0.925em;"}

- **Let's explore further the source code from the previous slide**:
    - The `dict` function make an empty dictionary `document`
    - Dictionaries store key-value pairs like `{"title": "Python Programming
    Guide"}`
    - The keys can be strings, numbers, or other hashable types
    - The values can be of any data type like `str`, `int`, and `float`
    - It is possible to lookup a value by its key as in `document["title"]`
    - **Document connection**: storing structured document information (e.g.,
    pages in a chapter) in a mapping!

:::

## Creating and using a set

```{pyodide}
#| autorun: true
#| max-lines: 10
# sets store unique items - useful for tracking document keywords!
keywords = {"python", "programming"}
print("Set type:", type(keywords))
keywords.add("documentation")
keywords.add("python")  # duplicate - won't be added again
keywords.add("python")  # another duplicate
keywords.add("tutorial")
print("Unique keywords:", keywords)
print("Keyword count:", len(keywords))
```

::: {.fragment .fade-up style="margin-top: -0.1em; font-size: 0.9em;"}

- A set is an un-ordered collection of unique values
- **How are sets similar to and different from lists?**

:::

## Details about set use in Python

::: {.incremental .fade-up style="margin-top: -0.1em; font-size: 0.95em;"}

- **Let's explore further the source code from the previous slide**:
    - Sets do not store duplicate values
    - The data in a set must be hashable
    - The `add` function places more data in a set
    - Repeated calls of `add` with `"python"` do not change the set
    - Be careful, `{}` is an empty dictionary, not a set!
    - **Document connection**: keep unique tags and keywords!
- Different collections have different properties and use cases
- **What operations can you perform on a these collections?**

:::

# Operations to perform on most collections

::: {.fragment .fade-right}
- {{< iconify fa6-solid ruler-horizontal >}} Determine the *length* of a collection
- {{< iconify fa6-solid plus-minus >}} *Add* an element to or *remove* element from a collection
- {{< iconify fa6-solid hand-pointer >}} *Access* an element in a collection
- {{< iconify fa6-solid magnifying-glass >}} Determine if a collection *contains* an element
- {{< iconify fa6-solid arrows-rotate >}} *Iterate* through all of the elements in a collection
- {{< iconify fa6-solid scissors >}} *Slice* a collection to get a subset of its elements
:::

## Sizing and slicing collections

```{pyodide}
#| autorun: true
#| max-lines: 5
# working with document content and metadata
title = "Document Engineering Guide"
sections = ["Introduction", "Methods", "Examples", "Conclusion"]
metadata = ("Guide", "Engineering")
properties = {"type": "manual", "version": 2, "active": True}
tags = {"python", "docs", "engineering", "tutorial", "python", "docs"}
print("Lengths:", len(title), len(sections), len(metadata), len(properties), len(tags))
```

<p class="tightspacer">

```{pyodide}
#| autorun: true
#| max-lines: 5
# slicing collections to extract parts
title = "Document Engineering Guide"
sections = ["Introduction", "Methods", "Examples", "Conclusion"]
metadata = ("Guide", "Engineering", "Tutorial", "2025")
print("Title slice:", title[9:20])  # "Engineering"
print("First word:", title[0:8])    # "Document"
print("Last sections:", sections[2:])  # ["Examples", "Conclusion"]
print("First two metadata:", metadata[:2])  # ("Guide", "Engineering")
```

## Iterating through lists and tuples

```{pyodide}
#| autorun: true
#| max-lines: 6
# processing document sections and metadata
chapters = ["Intro", "Setup", "Examples"]
doc_metadata = ("Technical Guide", "v1.0", "2025", "English")
print("Chapters:")
for chapter in chapters:
    print("  " + chapter)
print()
print("Metadata:")
for item in doc_metadata:
    print("  " + str(item))
```

## Iterating through sets and strings

```{pyodide}
#| autorun: true
#| max-lines: 5
# working with document keywords and text
document_tags = {"python", "tutorial", "beginners"}
filename = "guide.pdf"
print("Document Tags:")
for tag in document_tags:
    print("  " + tag)
print()
print("Filename Characters:")
for character in filename:
    print("  " + character)
```

## Iterating through a dictionary

```{pyodide}
#| autorun: true
#| max-lines: 5
# processing document properties
document_info = {"title": "Python Guide", "pages": 150, "language": "English"}

print("Method 1 - Keys only:")
for key in document_info:
    print("\t", key, "->", document_info[key])
print("Method 2 - Items (key-value pairs):")
for key, value in document_info.items():
    print("\t", key, "->", value)
print("Method 3 - Explicit keys:")
for key in document_info.keys():
    print("\t", key, "->", document_info[key])
```

## Mutable and immutable collections

::: {.fragment .fade-right}

- **Mutable Collections**: *can be changed after creation*
  - Lists (`list`): great for document sections that may change
  - Dictionaries (`dict`): perfect for document properties
  - Sets (`set`): ideal for collections of unique keywords

:::

::: {.fragment .fade-right style="margin-top: -0.75em;"}

- **Immutable Collections**: *cannot be changed after creation*
  - Tuples (`tuple`): excellent for fixed document metadata
  - Strings (`str`): text content that won't be modified

:::

::: {.fragment .fade-up style="margin-top: -0.75em; font-size: 0.85em;"}

- {{< iconify fa6-solid lightbulb >}} **Understanding mutability helps
prosegrammers choose the right collection type for document data! Carefully pick
your collection!**

:::

## Containment checking for collections

```{pyodide}
#| autorun: true
#| max-lines: 11
# checking if content exists in document data
title = "Python Programming"
chapters = ["Introduction", "Basics", "Advanced", "Conclusion"]
metadata = ("Guide", "v2.0")
document_info = {"author": "Jane Smith", "pages": 200, "language": "English"}
keywords = {"python", "programming", "tutorial", "beginner"}

print("'Programming' in title:", "Programming" in title)
print("'Tutorial' in title:", "Tutorial" in title)
print("'Basics' in chapters:", "Basics" in chapters)
print("'Guide' in metadata:", "Guide" in metadata)
print("'author' in document_info:", "author" in document_info)
print("'python' in keywords:", "python" in keywords)
```

## More containment checking

```{pyodide}
#| autorun: true
#| max-lines: 11
# testing for missing content in document data
title = "Python Programming"
chapters = ["Introduction", "Basics", "Advanced", "Conclusion"]
metadata = ("Guide", "v2.0")
document_info = {"author": "Jane Smith", "pages": 200, "language": "English"}
keywords = {"python", "programming", "tutorial", "beginner"}

print("'Java' in title:", "Java" in title)
print("'Appendix' in chapters:", "Appendix" in chapters)
print("'v3.0' in metadata:", "v3.0" in metadata)
print("'publisher' in document_info:", "publisher" in document_info)
print("'advanced' in keywords:", "advanced" in keywords)
print("'Python' in keywords:", "Python" in keywords)  # case matters!
```

## Working with document content

```{python}
def find_document_in_library(library: list, document_name: str) -> bool:
    """Check if a document exists in our document library."""
    # assume the document is not in the library
    found = False
    # check if the document name is in the library
    if document_name in library:
        found = True
    # return boolean to indicate whether document was found
    return found

# test with sample document library
my_library = ["Python Guide", "Web Development", "Data Analysis"]
result = find_document_in_library(my_library, "Python Guide")
print("Found 'Python Guide':", result)
```

::: {.incremental .fade-right}

- How does `find_document_in_library` work?
- Can you explain the its output? Can you enhance it? How?

:::

## Working with document metadata

```{python}
def check_document_property(metadata: tuple, property_name: str) -> bool:
    """Check if a specific property exists in document metadata."""
    # assume the property is not in the metadata
    found = False
    # check if the property name is in the metadata tuple
    if property_name in metadata:
        found = True
    # return boolean to indicate whether property was found
    return found

# test with sample document metadata
doc_metadata = ("User Manual", "v2.1", "English", "PDF")
result = check_document_property(doc_metadata, "PDF")
print("Contains 'PDF' format:", result)
```

::: {.incremental .fade-right style="margin-top: -0.1em; font-size: 0.75em;"}

- What is the type of the parameter called `metadata`?
- What is the type of the parameter called `property_name`?
- What is the return type of `check_document_property`?

:::

## Key features of Python: expressions

::: fragment

##### Defining and evaluating expressions

```{pyodide}
#| autorun: true
#| max-lines: 6
# Python makes calculations easy and readable
pages_per_chapter = 15
total_chapters = 8
total_pages = pages_per_chapter * total_chapters
print("Total pages in document:", total_pages)
```

:::

::: {.fragment .fade-right style="margin-top: -0.1em; font-size: 0.95em;"}

- `pages_per_chapter` is a variable
- `total_pages` is a variable defined by an expression
- The `*` operator multiplies two numbers
- `print` outputs text to the console or the slides

:::

## Key features of Python: variables

::: fragment

##### Declaring and using variables with types

```{pyodide}
#| autorun: true
#| max-lines: 6
# Variables store different types of document information
document_title = "Python for Beginners"
page_count = 156
is_published = True
print("Title:", document_title, "| Pages:", page_count, "| Published:", is_published)
```

:::

::: {.fragment .fade-right style="margin-top: -0.1em; font-size: 0.95em;"}

- `document_title` is a variable of type `str`
- `page_count` is a variable of type `int`
- `is_published` is a variable of type `bool`
- `print` outputs text to the console or the slides

:::

## Key features of Python: collections

::: fragment

### Creating and using collections

```{pyodide}
#| autorun: true
#| max-lines: 6
# Collections organize multiple pieces of information
chapter_titles = ["Introduction", "Variables", "Functions", "Collections"]
print("Chapter list:", chapter_titles)
print("First chapter:", chapter_titles[0])
```

:::

::: {.fragment .fade-right style="margin-top: -0.1em; font-size: 0.95em;"}

- `chapter_titles` is a variable of type `list`
- Each value inside of `chapter_titles` is a `str`
- `chapter_titles[0]` accesses the first list element
- `print` outputs text to the console or the slides

:::

## Building your Python foundation

::: {.fragment style="margin-top: 0.1em; font-size: 0.85em;"}

- **Master the fundamentals**: sequence, selection, iteration
- **Understand collections**: strings, lists, tuples, dictionaries, sets
- **Use document examples**: titles, chapters, metadata, keywords
- **Connect Python to document engineering**: 
  - Process text and analyze content
  - Organize document information systematically
  - Automate repetitive document tasks

:::

::: {.fragment .fade .boxed-content style="margin-top: 0.1em; font-size: 0.85em;"}

{{< iconify fa6-solid rocket >}} How exciting! You're ready to become a
prosegrammer! **Python + documents = powerful automation and analysis
capabilities!**

:::

## Overall document engineering setup

::: {.fragment .callout-note icon=true title="Tips for effective document engineering setup"}

- Devote time outside class to installing and configuring tools
- Confirm that most tools work during the this week's lab session
- Create and render test documents with the provided examples
- Complete the first document engineering project on time
- Contribute to collaborative documentation projects
- Prepare for first document engineering skill check

- {{< iconify fa6-solid rocket >}} **Get ready for an exciting journey into document engineering!**
- {{< iconify fa6-solid lightbulb >}} **If you are having trouble, publicly ask for help on Discord!**
- {{< iconify fa6-solid key >}} **If you would like to use a token, please contact the course instructor!**

:::

# Document engineering skill-check reminders

::: {.fragment .fade-right}

- {{< iconify fa6-solid clipboard-check >}} **What is a skill-check?**
- {{< iconify fa6-solid calendar >}} **When do skill-checks happen?**
- {{< iconify fa6-solid code >}} **What programming tasks are involved?**
- {{< iconify fa6-solid rocket >}} **How do I complete a skill-check successfully?**

:::

::: {.fragment .fade .boxed-content style="font-size: 0.8em;"}

{{< iconify fa6-solid lightbulb >}} **Programming assessments for your document
engineering skills!**

:::

## What is a skill-check?

::: {.incremental .fade-right style="margin-top: -0.1em; font-size: 0.925em;"}

- **Programming tasks** completed on certain Fridays during class
- **Individual assessment** of your document engineering skills
- **GitHub Classroom repository** provided as your starting point
- **Contains `TODO` markers** and blank functions for you to complete
- **Automated checking** ensures your solution meets requirements
- **Time-limited** completion of tasks during the class session

:::

::: {.fragment .fade .boxed-content style="font-size: 0.9em;"}

{{< iconify fa6-solid lightbulb >}} **It's a focused coding challenge that
assesses what you've learned and confirms that you have tools setup correctly!**

:::

## Step 1: Navigate to the `exam/` directory

```bash
# navigate to your skill-check repository after cloning
cd <your-skillcheck-repository-name>

# navigate to the exam directory where all the work happens
cd exam

# verify you're in the right place for the skill-check
ls -la
```

::: {.fragment .fade-up style="margin-top: -0.1em; font-size: 0.85em;"}

- **Important**: All skill-check work happens in the `exam/` directory
- You should see: `questions/`, `tests/`, `gatorgrade.yml`, `pyproject.toml`
- The `questions/` directory contains files with `TODO` markers to complete

:::

## Step 2: Run the assessment tool

```bash
# Run gatorgrade to see what needs to be completed
uvx gatorgrade

# This will show you:
# ‚úÖ Checks that are already passing
# ‚ùå Checks that need work
# üìä Overall completion percentage
```

::: {.fragment .fade-up style="margin-top: -0.1em; font-size: 0.85em;"}

- **`gatorgrade`** is the automated assessment tool
- **Red X marks** show what still needs to be fixed
- **Green checkmarks** show completed requirements
- **Goal**: Get 100% of all checks passing

:::

## Step 3: Complete the programming tasks

::: {.incremental .fade-right style="margin-top: -0.1em; font-size: 0.9em;"}

- **Open files** in the `questions/` directory (e.g., `question_one.py`)
- **Find `TODO` markers** that indicate where to add code
- **Read function docstrings** to understand what each function should do
- **Write Python code** to implement the required functionality
- **Add comments** to explain your code clearly
- **Remove `TODO` markers** when you complete each section

:::

::: {.fragment .fade .boxed-content style="font-size: 0.85em;"}

**Don't forget**: You need to implement the functions AND remove the TODO
markers!

:::

## Step 4: Test your progress frequently

```bash
# Run gatorgrade after making changes
uvx gatorgrade

# You should see your completion percentage improve
# Keep working until you reach 100%

# For specific test details, you can also run:
uv run pytest -v
```

::: {.fragment .fade-up style="margin-top: -0.1em; font-size: 0.85em;"}

- **Run `gatorgrade` frequently** to track your progress
- **Each change** should improve your completion percentage
- **Don't wait** until the end to test your work
- **Green checkmarks** confirm your code is working correctly

:::

## Step 5: Submit your work with Git

```bash
# Add your completed work to Git staging area
git add .

# Create a commit with a descriptive message
git commit -m "Complete skill-check programming tasks"

# Push your work to GitHub
git push origin main
```

::: {.fragment .fade-up style="margin-top: -0.1em; font-size: 0.85em;"}

- **Push frequently** during the skill-check, not just at the end
- **Use descriptive commit messages** that explain what you completed
- **GitHub Actions** will automatically run additional tests on your code
- **Final score** depends on both local `gatorgrade` and GitHub Actions results

:::

## Common skill-check mistakes to avoid

::: {.incremental .fade-right style="margin-top: -0.1em; font-size: 0.9em;"}

- **Not reading instructions carefully** - always read the entire README.md
- **Forgetting to remove `TODO` markers** - this causes automatic failures
- **Not running `gatorgrade` frequently** - test your work as you go
- **Waiting until the last minute to push** - commit and push regularly
- **Modifying test files** - never change files in the `tests/` directory
- **Not completing the Honor Code** - you must digitally sign the pledge

:::

::: {.fragment .fade .boxed-content style="font-size: 0.85em;"}

**Remember**: Read carefully, code thoughtfully, test frequently, and submit
regularly!

:::

## Skill-check success checklist

::: {.fragment .callout-tip icon=true title="Before you consider your skill-check complete"}

- [ ] **Navigate** to the `exam/` directory in your repository
- [ ] **Run** `uvx gatorgrade` and achieve 100% completion
- [ ] **Complete** all programming tasks in the `questions/` directory
- [ ] **Remove** all `TODO` markers from your code
- [ ] **Add** meaningful comments to explain your code
- [ ] **Complete** the Honor Code section in README.md
- [ ] **Commit** and **push** your work to GitHub regularly
- [ ] **Verify** GitHub Actions shows a passing build

:::

## Reminder of course goals

::: {.fragment .fade style="margin-top: -0.15em; font-size: 0.9em;"}

- **Document Creation**:
  - Design and implement document generation workflows
  - Test all aspects of documents to ensure quality and accuracy
  - Create frameworks for automated document production
- **Document Analysis**:
  - Collect and analyze data about document usage and quality
  - Visualize insights to improve documentation strategies
- **Communicate** results and best practices for document engineering
- **Check [syllabus](/syllabus/index.qmd) for details about Document Engineering
course!**

:::
